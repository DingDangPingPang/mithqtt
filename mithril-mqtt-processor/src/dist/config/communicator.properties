# Communicator configuration

# Communicator

# Communicator implementation (full qualified class name)
communicator.class = com.github.longkerdandy.mithril.mqtt.communicator.hazelcast.processor.HazelcastProcessorCommunicator

# This is the topic prefix that broker instance consume. (full topic is like mithril.mqtt.broker.{brokerId})
# You should create this Kafka topics before starting each broker.
# In Kafka there cannot be more consumer instances than partitions.
# eg. Each broker instance running 4 consumer threads, which means there should be at least 4 partitions.
communicator.broker.topic = mithril.mqtt.broker

# This is the topic that all processor instance consume with the same consumer group. (to achieve load balance)
# You should create this Kafka topic before starting processor.
# In Kafka there cannot be more consumer instances than partitions.
# eg. There are 4 processor instances, each running 16 consumer threads, which means there should be at least 64 partitions.
communicator.processor.topic = mithril.mqtt.processor

# This is the topic that processor will pass message to 3rd party application
# You should create this Kafka topic before starting processor & your application.
communicator.application.topic = mithril.mqtt.application

# Hazelcast

# Using this policy one can control the behavior what should to be done when an item is about to be added to the ringbuffer,
# but there is 0 remaining capacity.
# Overflowing happens when a time-to-live is set and the oldest item in the ringbuffer (the head) is not old enough to expire.
# Value 0 means:
# Using this policy the oldest item is overwritten no matter it is not old enough to retire. Using this policy you are
# sacrificing the time-to-live in favor of being able to write.
# Value 1 means:
# Using this policy the call will fail immediately and the oldest item will not be overwritten before it is old enough
# to retire. So this policy sacrificing the ability to write in favor of time-to-live.
# The advantage of fail is that the caller can decide what to do since it doesn't trap the thread due to backoff.
broker.overflowPolicy = 0
processor.overflowPolicy = 0
application.overflowPolicy = 0

# The number of threads reading from hazelcast ringbuffer
consumer.threads = 16
